{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Lauri/WebstormProjects/action-verite-project/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./storage.service\";\nimport * as i2 from \"./cards.service\";\nexport let GameService = /*#__PURE__*/(() => {\n  class GameService {\n    constructor(storageService, cardsService) {\n      this.storageService = storageService;\n      this.cardsService = cardsService;\n      this.gameState = new BehaviorSubject({\n        players: [],\n        currentPlayerIndex: 0,\n        mode: null,\n        consecutiveTruths: 0,\n        drawnCards: new Set()\n      });\n      this.gameState$ = this.gameState.asObservable();\n      // Essaie de charger l'état sauvegardé au démarrage\n      this.loadGameState();\n    }\n    initGame(players, mode) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const newState = {\n          players,\n          currentPlayerIndex: 0,\n          mode,\n          consecutiveTruths: 0,\n          drawnCards: new Set()\n        };\n        yield _this.storageService.savePlayers(players);\n        yield _this.saveGameState(newState);\n        _this.gameState.next(newState);\n      })();\n    }\n    loadGameState() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const savedState = localStorage.getItem('gameState');\n          if (savedState) {\n            const parsed = JSON.parse(savedState);\n            parsed.drawnCards = new Set(parsed.drawnCards || []);\n            _this2.gameState.next(parsed);\n          }\n        } catch (e) {\n          console.log('Erreur lors du chargement de l\\'état', e);\n        }\n      })();\n    }\n    saveGameState(state) {\n      return _asyncToGenerator(function* () {\n        try {\n          // Convertit Set en Array pour le JSON\n          const stateToSave = {\n            ...state,\n            drawnCards: Array.from(state.drawnCards)\n          };\n          localStorage.setItem('gameState', JSON.stringify(stateToSave));\n        } catch (e) {\n          console.log('Erreur lors de la sauvegarde de l\\'état', e);\n        }\n      })();\n    }\n    getCurrentPlayer() {\n      const state = this.gameState.value;\n      if (state.players.length === 0) return null;\n      return state.players[state.currentPlayerIndex];\n    }\n    drawCard(type) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const state = _this3.gameState.value;\n        const currentPlayer = _this3.getCurrentPlayer();\n        if (!currentPlayer || !state.mode) return null;\n        const card = _this3.cardsService.drawRandomCard(state.mode.id, type, currentPlayer, state.drawnCards);\n        if (card) {\n          // Marque la carte comme tirée si non répétable\n          if (!card.repetable) {\n            state.drawnCards.add(card.id);\n          }\n          // Met à jour le compteur de vérités consécutives\n          if (type === 'vérité') {\n            state.consecutiveTruths++;\n          } else {\n            state.consecutiveTruths = 0;\n          }\n          _this3.gameState.next({\n            ...state\n          });\n          yield _this3.saveGameState({\n            ...state\n          });\n        }\n        return card;\n      })();\n    }\n    nextPlayer() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const state = _this4.gameState.value;\n        const nextIndex = (state.currentPlayerIndex + 1) % state.players.length;\n        const newState = {\n          players: state.players,\n          currentPlayerIndex: nextIndex,\n          mode: state.mode,\n          consecutiveTruths: 0,\n          drawnCards: new Set() // Réinitialise pour le nouveau joueur\n        };\n        _this4.gameState.next(newState);\n        yield _this4.saveGameState(newState);\n      })();\n    }\n    canChooseTruth() {\n      const state = this.gameState.value;\n      return state.consecutiveTruths < 3;\n    }\n    getConsecutiveTruths() {\n      return this.gameState.value.consecutiveTruths;\n    }\n    getAllPlayers() {\n      return this.gameState.value.players;\n    }\n    getOtherPlayers() {\n      const state = this.gameState.value;\n      if (!state.players || state.players.length === 0) return [];\n      const currentPlayer = state.players[state.currentPlayerIndex];\n      // Retourne tous les joueurs sauf le joueur actuel\n      return state.players.filter(p => p.id !== currentPlayer.id);\n    }\n    resetGame() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        const newState = {\n          players: [],\n          currentPlayerIndex: 0,\n          mode: null,\n          consecutiveTruths: 0,\n          drawnCards: new Set()\n        };\n        _this5.gameState.next(newState);\n        yield _this5.saveGameState(newState);\n      })();\n    }\n    static {\n      this.ɵfac = function GameService_Factory(t) {\n        return new (t || GameService)(i0.ɵɵinject(i1.StorageService), i0.ɵɵinject(i2.CardsService));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: GameService,\n        factory: GameService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return GameService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}